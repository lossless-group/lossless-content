---
date_created: 2025-08-15
date_modified: 2025-08-17
---
# Our Approach: AI-Human Collaboration Principles

## Core Philosophy

Our approach to AI-augmented development is built on this fundamental principle:

> **AI tools are collaborative partners, not magic solutions**. 

Just as you wouldn't expect a new team member to deliver quality work without proper onboarding, clear requirements, and iterative feedback, AI tools require the same structured approach to collaboration. The Internet is abuzz with the majority of Vibe Coding tourists being somewhere between disappointed and maddeningly frustrated. [^xaz7sh]

[[concepts/Accelerated Context Engineering]] > [[concepts/Explainers for AI/Context Engineering|Context Engineering]] > [[concepts/Explainers for AI/Vibe Planning|Vibe Planning]] > [[Vocabulary/Vibe Coding|Vibe Coding]]
## The Team Member Analogy

Working with AI is remarkably similar to working with a highly capable but inexperienced developer (that is also ironically as naive and blameless as a three-year old.)
![Dash the Incredibles speedy superhero](https://www.writeups.org/wp-content/uploads/Dash-The-Incredibles-Dashiell-Parr-g.jpg)
### What AI Needs (Like Any Team Member)
- **Clear Specifications**: Detailed requirements, not vague requests
- **Context and Background**: Understanding of project goals and constraints
- **Clear and Specific Prompts**: that include attachments and line references to the context, background, and specifications. 
- **Iterative Feedback**: Regular check-ins and course corrections
- **Well-Defined Interfaces**: Clear inputs, outputs, and expectations
- **Structured Communication**: Consistent formats and protocols

### What AI Provides (Like a Skilled Contributor)
- **Rapid Prototyping**: Quick generation of initial implementations
- **Eagerness to use often skipped Best Practices**: Meaningful commit messages, code comments, updates to documentation, continuous test coverage, changelogs.
- **Pattern Recognition**: Identification of common structures and approaches
- **Consistent Output**: Reliable formatting and structure adherence
- **Broad Knowledge**: Access to extensive development patterns and practices
	- **Cross-Functional Competencies**:  Many human developers end up specializing in some related set of masteries, such as [[Vocabulary/Back-End Engineering|Back-End]], [[Vocabulary/Front-End|Front-End]], [[Vocabulary/Dev Ops|DevOps]], or [[Vocabulary/Data Science|Data Science]]
- **Assistance with Developer Blind Spots and Atrophy**: AI models are uniquely competent at many competencies that developers often never gain mastery over or have long forgotten.  
	- willingness to read through the entirety of documentation and instructions (though they will forget it quickly)
	- complex and less-used git and version control commands.
	- complex and less used command line commands.
	- fluency with [[concepts/Diagrams as Code|Diagrams as Code]], and willingness to thoroughly document all changes as they are made (if prompted).

### What AI brings that No Human Can:
- **24/7 Availability**: Always ready to assist and iterate.
- **100% can do attitude**: Models always greet any task no matter how arduous with a complementary if not sycophantic attitude. 
- **Industry-Wide, Instant Access Pattern Recognition**: The LLM will be incredibly knowledgeable about pretty much any language, framework, library, programming pattern, best practice. 
- **Instant First Drafts**: If upfront investments into documentation are good, copilots can produce large amounts of code almost instantly as long as the model vendor APIs are not over-trafficked. Their first drafts are often more error free than continuous iterations because they just print out established patterns. 
- **Instant Error Recognition**: Errors generated by programming languages and frameworks are notoriously hard for humans to read. A common way to lose time and focus was to copy error messages into Google and Stack Overflow to understand them, and hope to find some kind of explanation. 
- **Fuzzy Find on Caffeine**: Copilots can search large codebases for instances, patterns, syntax errors, often based on loose requests.  
### The Challenges AI will Introduce:
- reckless disregard and constant violations of DRY principles
- preference for lumping all code into one or a few files, significant avoidance of modular codebases with small individual files. [^e2kfhb]
- immediately leaping to generate large volumes of unnecessary code rather than well-thought through, well architected code
- defaults to universal variable and component names that can create naming collisions and often look meaningless to humans, and struggles to use meaningful names that reveal project context.
- huge attraction to taking shortcuts, like adding unnecessary libraries.
- complete obliviousness to its own ignorance
- assumes immediate comprehension of project, task, and prompt, whether or not it does, leading to rabbit holes, reversion, clean up, or bug squashing.  
- rarely asks follow up questions that improve understanding. 
- almost never goes to check project files that developers would always go to check, such as utils, styles, routes, etc.  They must be re-fed at every prompt, or explicitly told to.  
- has no working or long term memory that is not documented and reintroduced into the context window, so repeats the same mistakes over and over.
- to the extent there is a working memory, it's in feeder text to the [[concepts/Explainers for AI/Context Window|Context Window]], and relatively small work histories can lead to [[concepts/Explainers for AI/Context Rot|Context Rot]] and result in an "overwhelmed" Copilot that is also unaware it is overwhelmed. 


## Key Principles

### 1.  Documentation-Driven Development
Before adopting copilots, thorough documentation was often developed AFTER code had been written. [[Vocabulary/Software Architecture|Architects]], [[Sources/Laerdal Entities/Laerdal Product Management|Product Managers]], and [[Vocabulary/UI Design|UI Designers]] would make the documentation needed to make a [[concepts/Design to Engineering Handoff|Design to Engineering Handoff]] It was a kind of output. Different kinds of documentation are used for different use cases and moments in the development cycle. 

#### 1a. ACE Toolkit: Recommended Documents
Our rabbit holes and endless hours of frustration has led us to a stable set of documents 
[[projects/ACE-It/Living Specifications|Living Specifications]], [[projects/ACE-It/Blueprints|Blueprints]], [[projects/ACE-It/Reminders|Reminders]], and [[projects/ACE-It/Prompts|Prompts]]

| Documentation Type | [[projects/ACE-It/Living Specifications\|Living Specifications]]                                                           | [[projects/ACE-It/Blueprints\|Blueprints]]                                                                                  | [[projects/ACE-It/Reminders\|Reminders]]                                      | [[projects/ACE-It/Prompts\|Prompts]]                                                                                                                                                                           |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Use Patterns       | Vital to kickoff prompt. Refer to it accompanying every prompt or as necessary.                                            | Vital to kickoff prompt. Refer to it accompanying every prompt or as necessary.                                             | As needed, but usually one or more involved in every prompt.                  | Developed on the fly prior to prompting for development.                                                                                                                                                       |
| Development Phase  | Early, prior to moving into design, often started and then iterated on for prolonged periods before moving to development. | Iteratively, usually to synthesize patterns across the project or across many projects as per developer or team preference. | Upon repeat frustration with the same naivety, forgetfulness, or assumptions. | Instead of just writing a prompt in the chat interface, reference the specification and work with the copilot in the role of product manager.  Develop a comprehensive prompt for a single task scope of work. |
| Frequency of Use   | Frequently during the build, but rarely if every after.                                                                    | As needed, but usually front loaded for context accompanying a prompt.                                                      | As needed, but usually multiple times in a single work session.               | Usually once, or iteratively a few times if there is much discussion, iteration, or resets and reversions to make another attempt.                                                                             |
|                    | Planning                                                                                                                   | Reflective                                                                                                                  | Reflective                                                                    | Planning                                                                                                                                                                                                       |

### 2. Specification-Driven Development
Instead of asking "build me a login system," create and improve on templates and specifications that provide:
- [[concepts/Diagrams as Code|Diagrams as Code]] that show various kinds of architecture context.
- Technical stack, choices, and available libraries
- Technical constraints and requirements
- Scopes for different iterations or even versions
- User stories and acceptance criteria
- Integration points with existing systems
- Security and performance requirements, even at the prototype stage without clarifying them the copilot will get confused. 
- UI/UX guidelines, links to inspiration or sources to copy from, and direct access to mockups if possible

### LLM-TDD
[[concepts/Test-Driven Development|Test-Driven Development]] has been around for a while.  But, [[Vocabulary/Hacker Culture|Hacker Culture]] did away with that as well.  However, it's actually a really good way to focus the copilot on the task at hand. [^h5o9du]


### 2. Iterative Refinement
- Start with basic requirements and iterate
- Test and validate each iteration
- Refine specifications based on results
- Build complexity gradually

### 3. Human-AI [[Pair Programming]]
- AI handles repetitive and [[Vocabulary/Boilerplate Code|Boilerplate]] code
- Humans provide architectural decisions and creative solutions
- Continuous code review and quality assurance
- Regular alignment on project direction

### 4. Documentation as Communication
- Maintain living specifications
- Document decisions and reasoning
- Create reusable templates and patterns
- Share knowledge across team members

### 5. Quality First
- AI-generated code must meet the same standards as human code
	- AI Generated Code often will not meet Human standards on the first attempt at a prompt. Don't be frustrated. 
- Implement proper testing and validation workflows
- Regular security and performance reviews
- Code style and convention adherence

## Implementation Strategy

### Phase 0: Team ACE content repository
1. Create or access your documentation repository used for this process. 
2. Define the metadata (YAML [[Frontmatter]]) you intend to use for this content.  
3. We recommend everyone either use copilots to help with complex git commands, or using an easy to use app like [[Tooling/Software Development/Developer Experience/DevOps/GitKraken|GitKraken]] or [[Tooling/Software Development/Developer Experience/DevOps/Retcon|Retcon]]. There will be a ton of version control from here out, not just on content but on the code as well. 
4. Include example "Rules" or "Rulesets" that can be used for the different [[Vocabulary/AI Native Applications|AI Native]] [[concepts/Explainers for Tooling/Text Editors or IDEs|IDEs]].  (We switch between [[Tooling/AI-Toolkit/Generative AI/Code Generators/Windsurf IDE|Windsurf IDE]], [[Tooling/AI-Toolkit/Generative AI/Code Generators/Cursor|Cursor]], and [[Tooling/AI-Toolkit/Generative AI/Code Generators/Claude Code|Claude Code]].)
5. Make sure everyone knows how to create snippets in their [[concepts/Explainers for Tooling/Text Editors or IDEs|Text Editors or IDEs]], they are usually used for comments or boilerplate code but they are very very helpful as a sub for [[projects/ACE-It/Reminders|Reminders]]. 

### Phase 1: Iterate to a Living Specification
1. Ask the AI [[concepts/Explainers for AI/AI Copilots|Copilot]] to take on the role of "Senior Product Manager brought in to save a project that is behind schedule." 
2. Iterate cooperatively with your Senior Product Manager assistant on the [[projects/ACE-It/Living Specifications|Living Specification]] 
	1. Use commits liberally, the copilot can go haywire and edit things that were not requested. (We have [[projects/ACE-It/Reminders|Reminders]] that say to never overwrite anything unless specifically asked.)
	2. Review the [[projects/ACE-It/Living Specifications|Living Specification]] to sequence endeavors, features, and tasks.  
	3. Chunk work into reasonable "Phases" -- a phase should be something one Human-AI Pair can reasonably accomplish in one prolonged sitting. 
	4. Chunk Phases into [[projects/ACE-It/Prompts|Prompts]], which will start in the specification but as it becomes coherent and robust, including references to [[projects/ACE-It/Reminders|Reminders]] and [[projects/ACE-It/Blueprints|Blueprints]], it should be [[Vocabulary/Copypasta|Copypasta]] into it's own file. 
3. Include path references to any relevant documentation, codebases, repositories, or files, even recent projects that were successful.
4. Create template structures for common requests
	1. [[projects/ACE-It/Reminders|Reminders]] and [[projects/ACE-It/Blueprints|Blueprints]]
5. Set up quality assurance processes

### Phase 2: Integration  
1. Integrate AI tools into existing workflows
2. Train team members on effective AI collaboration
3. Establish feedback loops and improvement processes
4. Document successful patterns and practices

### Phase 3: Optimization
1. Refine AI prompts and specifications based on experience
2. Automate repetitive AI interactions
3. Scale successful patterns across projects
4. Continuous improvement of AI-human collaboration

## Success Metrics

- **Code Quality**: AI-generated code meets or exceeds human standards
- **Development Speed**: Measurable improvements in delivery velocity
- **Team Satisfaction**: Developers find AI tools helpful, not hindering
- **Maintainability**: AI-augmented code is as maintainable as traditional code
- **Learning Curve**: New team members can quickly adopt AI workflows

## Anti-Patterns to Avoid

### ❌ Vague Requests
- "Make it better"
- "Add some features"
- "Fix the bugs"

### ❌ Over-Reliance on AI
- Accepting all AI suggestions without review
- Skipping human architectural decisions
- Ignoring edge cases and error handling

### ❌ Under-Communication
- Not providing enough context
- Failing to specify constraints
- Assuming AI understands implicit requirements

### ✅ Effective Collaboration
- Detailed, specific requirements
- Regular review and validation
- Clear communication of constraints and expectations
- Human oversight of architectural decisions

---

*Remember: AI is a powerful collaborator when treated as such. The key to success is clear communication, iterative development, and maintaining human oversight of critical decisions.*

[^xaz7sh]: 2025, Aug 12. [Here is Why Vibe Coding is a Dead End for Juniors and Non-programmers](https://youtu.be/fzvx2bEUUnY?si=66HsRyCuqm9Wnijs) YouTube. [Zoran on C#](https://www.youtube.com/@zoran-horvat)

[^h5o9du]: 2025, May 26. [Test-driven development with GitHub Copilot: A beginner's practical guide](https://youtu.be/arn6hqERKn4?si=FuPaWkziTmayKxYt) YouTube. [[Tooling/Software Development/Developer Experience/GitHub|GitHub]]

[^e2kfhb]: 2024, Dec 04. [The two programming styles](https://youtu.be/ZJLJnLYwM5w?si=Fyp1nkCZO9u0GRRZ) YouTube. [[Sources/People/Kent Beck|Kent Beck]]

---
date_created: 2025-08-15
date_modified: 2025-08-17
---
# Our Approach: AI-Human Collaboration Principles

## Core Philosophy

Our approach to AI-augmented development is built on this fundamental principle:

> **AI tools are collaborative partners, not magic solutions**. 

Just as you wouldn't expect a new team member to deliver quality work without proper onboarding, clear requirements, and iterative feedback, AI tools require the same structured approach to collaboration. The Internet is abuzz with the majority of Vibe Coding tourists being somewhere between disappointed and maddeningly frustrated. [^xaz7sh]

[[concepts/Accelerated Context Engineering|Accelerated Context Engineering]] > [[concepts/Explainers for AI/Context Engineering|Context Engineering]] > [[concepts/Explainers for AI/Vibe Planning|Vibe Planning]] > [[Vocabulary/Vibe Coding|Vibe Coding]]
## The Team Member Analogy

Working with AI is remarkably similar to working with a highly capable but inexperienced developer (that is also ironically as naive and blameless as a three-year old.)
![Dash the Incredibles speedy superhero](https://www.writeups.org/wp-content/uploads/Dash-The-Incredibles-Dashiell-Parr-g.jpg)
***
### What AI Needs (Like Any Team Member)

- **Clear Specifications**: Detailed requirements, not vague requests
- **Context and Background**: Understanding of project goals and constraints
- **Clear and Specific Prompts**: that include attachments and line references to the context, background, and specifications. 
- **Iterative Feedback**: Regular check-ins and course corrections
- **Well-Defined Interfaces**: Clear inputs, outputs, and expectations
- **Structured Communication**: Consistent formats and protocols

***
### What AI Provides (Like a Skilled Contributor)
- **Rapid Prototyping**: Quick generation of initial implementations
- **Eagerness to use often skipped Best Practices**: Meaningful commit messages, code comments, updates to documentation, continuous test coverage, changelogs.
- **Pattern Recognition**: Identification of common structures and approaches
- **Consistent Output**: Reliable formatting and structure adherence
- **Broad Knowledge**: Access to extensive development patterns and practices
	- **Cross-Functional Competencies**:  Many human developers end up specializing in some related set of masteries, such as [[Vocabulary/Back-End Engineering|Back-End]], [[Vocabulary/Front-End|Front-End]], [[Vocabulary/Dev Ops|DevOps]], or [[Vocabulary/Data Science|Data Science]]
- **Assistance with Developer Blind Spots and Atrophy**: AI models are uniquely competent at many competencies that developers often never gain mastery over or have long forgotten.  
	- willingness to read through the entirety of documentation and instructions (though they will forget it quickly)
	- complex and less-used git and version control commands.
	- complex and less used command line commands.
	- fluency with [[concepts/Diagrams as Code|Diagrams as Code]], and willingness to thoroughly document all changes as they are made (if prompted).

***
### What AI brings that No Human Can:
- **24/7 Availability**: Always ready to assist and iterate.
- **100% can do attitude**: Models always greet any task no matter how arduous with a complementary if not sycophantic attitude. 
- **Industry-Wide, Instant Access Pattern Recognition**: The LLM will be incredibly knowledgeable about pretty much any language, framework, library, programming pattern, best practice. 
- **Instant First Drafts**: If upfront investments into documentation are good, copilots can produce large amounts of code almost instantly as long as the model vendor APIs are not over-trafficked. Their first drafts are often more error free than continuous iterations because they just print out established patterns. 
- **Instant Error Recognition**: Errors generated by programming languages and frameworks are notoriously hard for humans to read. A common way to lose time and focus was to copy error messages into Google and Stack Overflow to understand them, and hope to find some kind of explanation. 
- **Fuzzy Find on Caffeine**: Copilots can search large codebases for instances, patterns, syntax errors, often based on loose requests.  

***
### The Challenges AI will Introduce:
- **Leaps into generating large volumes** of unnecessary code rather than well-crafted, well-architected code
	- **Disregards the [[concepts/DRY Principle]]**, reckless generation of redundant or unnecessary code. 
	- **Defaults to lumping** all code into one or a few files, to an extreme. [^e2kfhb]
- **Will overwrite working, valuable code:** that no engineer would even think to overwrite. 
	- **Creates a hyper-vigilance with version control**: which then changes the pace at which commits and pull requests happen. 
- **Needs continuous orientation** to either be aware of or generate modular code with small individual files.  
	- **Ignores and is oblivious to standard project files** that developers would always go to check, such as utils, styles, routes, etc.  They must be re-fed at every prompt, or explicitly told to go to the path and review.  
- **Defaults to universal variable and component names** that can create naming collisions and look meaningless to humans.
	- **Struggles to use meaningful names** that reveal project context.
	- **Meaningful naming must be explicit in prompts**
- **Lazy and stubborn** when instructions are not completely clear. Prone to take shortcuts, like adding unnecessary libraries. Will often change one or two lines and say its fixed and working when not even close. 
- **Oblivious to its own ignorance**: the model will not proactively ask questions or reveal confusion.
	- **Models assume immediate comprehension** of project, task, and prompt, and will communicate with 100% confidence. This will leading to rabbit holes, reversion, clean-up and refactor, or bug squashing.  
	- **Rarely asks follow up questions** that improve understanding. Thus, the ACE toolkit needs to be fully written and loaded into the context window, with subsequent kit ready for course correction or the next task. 
- **Does not learn**: ironically, once a model is trained and available it no longer learns without workflows of fine tuning.  There is nothing resembling either working or long term memory. The only fix, and an arduous and imperfect one, is that everything is continuously documented, and necessary context is reintroduced into the context window at every step.  Regardless, the model will repeat the same mistakes over and over.
- **Quick to overwhelm:** Feeding the [[concepts/Explainers for AI/Context Window|Context Window]] works wonders, and relatively small work histories can lead to [[concepts/Explainers for AI/Context Rot|Context Rot]] and result in an "overwhelmed" Copilot. The model is also unaware it is overwhelmed, so will not tell you.  You will just notice things taking longer, the model second guessing itself or going on tangents that seem quite like a nervous breakdown. 


## Key Principles

### 1.  Documentation-Driven Development
#### Before Copilots:
Before adopting copilots, thorough documentation was often developed AFTER code had been written. [[Vocabulary/Software Architecture|Architects]], [[Sources/Laerdal Entities/Laerdal Product Management|Product Managers]], and [[Vocabulary/UI Design|UI Designers]] would make the documentation needed for the [[concepts/Design to Engineering Handoff|Design to Engineering Handoff]]. The real documentation was usually a reflective output or deliverable. 

#### With Copilots:
To get the most out of Human + Copilot cooperative workflows, thorough documentation needs to developed BEFORE, and DURING the development phase.  And documentation needs to have its own framework, as if all the information is in the specification, it's likely the specification + the prompt and action will exceed the context window -- thus really key information could be forgotten. 

In our experience, developing and having a framework of using different kinds of documentation that can be in different use cases, and as either setup, intervention, or wrap up to tasks in the development cycle. 
##### Diagrams are Lifeblood
Of course architectural diagrams had their role and were helpful before copilots.  Now, they are essential.  AI models are genius at generating [[concepts/Diagrams as Code|Diagrams as Code]] or [[lost-in-public/explorations/Diagrams-from-Text|Diagrams-from-Text]], our experience is that [[Tooling/Software Development/Frameworks/Web Frameworks/Mermaid.js|Mermaid.js]], an open source JavaScript library, has everything we've needed. 


#### 1a. ACE Toolkit: Recommended Documents
Our rabbit holes and endless hours of frustration has led us to a stable set of documents 
[[projects/ACE-It/Docs-Kit/Living Specifications|Living Specifications]], [[projects/ACE-It/Docs-Kit/Blueprints|Blueprints]], [[projects/ACE-It/Docs-Kit/Reminders|Reminders]], and [[projects/ACE-It/Docs-Kit/Prompts|Prompts]]

| Documentation Type | [[projects/ACE-It/Docs-Kit/Living Specifications\|Living Specifications]]                                                           | [[projects/ACE-It/Docs-Kit/Blueprints\|Blueprints]]                                                                                  | [[projects/ACE-It/Docs-Kit/Reminders\|Reminders]]                                      | [[projects/ACE-It/Docs-Kit/Prompts\|Prompts]]                                                                                                                                                                           |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Use Patterns       | Vital to kickoff prompt. Refer to it accompanying every prompt or as necessary.                                            | Vital to kickoff prompt. Refer to it accompanying every prompt or as necessary.                                             | As needed, but usually one or more involved in every prompt.                  | Developed on the fly prior to prompting for development.                                                                                                                                                       |
| Development Phase  | Early, prior to moving into design, often started and then iterated on for prolonged periods before moving to development. | Iteratively, usually to synthesize patterns across the project or across many projects as per developer or team preference. | Upon repeat frustration with the same naivety, forgetfulness, or assumptions. | Instead of just writing a prompt in the chat interface, reference the specification and work with the copilot in the role of product manager.  Develop a comprehensive prompt for a single task scope of work. |
| Frequency of Use   | Frequently during the build, but rarely if every after.                                                                    | As needed, but usually front loaded for context accompanying a prompt.                                                      | As needed, but usually multiple times in a single work session.               | Usually once, or iteratively a few times if there is much discussion, iteration, or resets and reversions to make another attempt.                                                                             |
| Cognitive State    | Planning                                                                                                                   | Reflective                                                                                                                  | Reflective                                                                    | Planning                                                                                                                                                                                                       |

### 2. Specification-Driven Development
Instead of asking "build me a login system," create and improve on templates and specifications that provide:
- [[concepts/Diagrams as Code|Diagrams as Code]] that show various kinds of architecture context.
- Technical stack, choices, and available libraries
- Technical constraints and requirements
- Scopes for different iterations or even versions
- User stories and acceptance criteria
- Integration points with existing systems
- Security and performance requirements, even at the prototype stage without clarifying them the copilot will get confused. 
- UI/UX guidelines, links to inspiration or sources to copy from, and direct access to mockups if possible

### 3. LLM-TDD
Not that long ago, [[concepts/Test-Driven Development|Test-Driven Development]] was nearly mandatory practice.  But, [[Vocabulary/Hacker Culture|Hacker Culture]] cast it aside.  Well, TDD is back to being mandatory if you want to have drama-free cooperation with AI Models. 

Good news: while I've never met a software developer that likes writing tests, all AI Models are almost eager to write them.  (AI likes best practices). They are also magically fast and accurate at writing tests

Tests that serve as an additional input to the prompt/task are noticeably valuable, as its a really good way to focus the copilot on the task at hand. [^h5o9du] 

Tests also **_prevent disaster_**. As discussed before, AI Models will naively and enthusiastically overwrite working, valuable code... and not even notice that it did. While some people actually read through every line of code written and changed before accepting, our experience is that when documentation and prompts are airtight, you can get thousands of lines of new or changed code in less than 2 minutes.  Clicking accept and praying for the best is tempting.  The only way to catch that kind of disaster quickly is to run a test, revert to last commit, and do prompt again while explicitly stating: "Do not overwrite code."


### 2. Iterative Refinement
- Start with basic requirements and iterate
- Test and validate each iteration
- Refine specifications based on results
- Build complexity gradually

### 3. Human-AI [[Pair Programming]]
- AI handles repetitive and [[Vocabulary/Boilerplate Code|Boilerplate]] code
- Humans provide architectural decisions and creative solutions
- Continuous code review and quality assurance
- Regular alignment on project direction

### 4. Documentation as Communication
- Maintain living specifications
- Document decisions and reasoning
- Create reusable templates and patterns
- Share knowledge across team members

### 5. Quality First
- AI-generated code must meet the same standards as human code
	- AI Generated Code often will not meet Human standards on the first attempt at a prompt. Don't be frustrated. 
- Implement proper testing and validation workflows
- Regular security and performance reviews
- Code style and convention adherence

## Implementation Strategy

### Phase 0: Team ACE content repository
1. Create or access your documentation repository used for this process. 
2. Define the metadata (YAML [[Vocabulary/Frontmatter]]) you intend to use for this content.  
3. We recommend everyone either use copilots to help with complex git commands, or using an easy to use app like [[Tooling/Software Development/Developer Experience/DevOps/GitKraken|GitKraken]] or [[Tooling/Software Development/Developer Experience/DevOps/Retcon|Retcon]]. There will be a ton of version control from here out, not just on content but on the code as well. 
4. Include example "Rules" or "Rulesets" that can be used for the different [[Vocabulary/AI Native Applications|AI Native]] [[concepts/Explainers for Tooling/Text Editors or IDEs|IDEs]].  (We switch between [[Tooling/AI-Toolkit/Generative AI/Code Generators/Windsurf IDE|Windsurf IDE]], [[Tooling/AI-Toolkit/Generative AI/Code Generators/Cursor|Cursor]], and [[Tooling/AI-Toolkit/Generative AI/Code Generators/Claude Code|Claude Code]].)
5. Make sure everyone knows how to create snippets in their [[concepts/Explainers for Tooling/Text Editors or IDEs|Text Editors or IDEs]], they are usually used for comments or boilerplate code but they are very very helpful as a sub for [[projects/ACE-It/Docs-Kit/Reminders|Reminders]]. 

### Phase 1: Iterate to a Living Specification
1. Ask the AI [[concepts/Explainers for AI/AI Copilots|Copilot]] to take on the role of "Senior Product Manager brought in to save a project that is behind schedule." 
2. Iterate cooperatively with your Senior Product Manager assistant on the [[projects/ACE-It/Docs-Kit/Living Specifications|Living Specification]] 
	1. Use commits liberally, the copilot can go haywire and edit things that were not requested. (We have [[projects/ACE-It/Docs-Kit/Reminders|Reminders]] that say to never overwrite anything unless specifically asked.)
	2. Review the [[projects/ACE-It/Docs-Kit/Living Specifications|Living Specification]] to sequence endeavors, features, and tasks.  
	3. Chunk work into reasonable "Phases" -- a phase should be something one Human-AI Pair can reasonably accomplish in one prolonged sitting. 
	4. Chunk Phases into [[projects/ACE-It/Docs-Kit/Prompts|Prompts]], which will start in the specification but as it becomes coherent and robust, including references to [[projects/ACE-It/Docs-Kit/Reminders|Reminders]] and [[projects/ACE-It/Docs-Kit/Blueprints|Blueprints]], it should be [[Vocabulary/Copypasta|Copypasta]] into it's own file. 
3. Include path references to any relevant documentation, codebases, repositories, or files, even recent projects that were successful.
4. Create template structures for common requests
	1. [[projects/ACE-It/Docs-Kit/Reminders|Reminders]] and [[projects/ACE-It/Docs-Kit/Blueprints|Blueprints]]
5. Set up quality assurance processes

### Phase 2: Integration  
1. Integrate AI tools into existing workflows
2. Train team members on effective AI collaboration
3. Establish feedback loops and improvement processes
4. Document successful patterns and practices

### Phase 3: Optimization
1. Refine AI prompts and specifications based on experience
2. Automate repetitive AI interactions
3. Scale successful patterns across projects
4. Continuous improvement of AI-human collaboration

## Success Metrics

- **Code Quality**: AI-generated code meets or exceeds human standards
- **Development Speed**: Measurable improvements in delivery velocity
- **Team Satisfaction**: Developers find AI tools helpful, not hindering
- **Maintainability**: AI-augmented code is as maintainable as traditional code
- **Learning Curve**: New team members can quickly adopt AI workflows

## Anti-Patterns to Avoid

### ❌ Vague Requests
- "Make it better"
- "Add some features"
- "Fix the bugs"

### ❌ Over-Reliance on AI
- Accepting all AI suggestions without review
- Skipping human architectural decisions
- Ignoring edge cases and error handling

### ❌ Under-Communication
- Not providing enough context
- Failing to specify constraints
- Assuming AI understands implicit requirements

### ✅ Effective Collaboration
- Detailed, specific requirements
- Regular review and validation
- Clear communication of constraints and expectations
- Human oversight of architectural decisions

---

*Remember: AI is a powerful collaborator when treated as such. The key to success is clear communication, iterative development, and maintaining human oversight of critical decisions.*

[^xaz7sh]: 2025, Aug 12. [Here is Why Vibe Coding is a Dead End for Juniors and Non-programmers](https://youtu.be/fzvx2bEUUnY?si=66HsRyCuqm9Wnijs) YouTube. [Zoran on C#](https://www.youtube.com/@zoran-horvat)

[^h5o9du]: 2025, May 26. [Test-driven development with GitHub Copilot: A beginner's practical guide](https://youtu.be/arn6hqERKn4?si=FuPaWkziTmayKxYt) YouTube. [[Tooling/Software Development/Developer Experience/GitHub|GitHub]]

[^e2kfhb]: 2024, Dec 04. [The two programming styles](https://youtu.be/ZJLJnLYwM5w?si=Fyp1nkCZO9u0GRRZ) YouTube. [[Sources/People/Kent Beck|Kent Beck]]
